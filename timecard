#!/usr/bin/env python2

from __future__ import division

import argparse
import collections
import datetime
import itertools
import operator
import os
import os.path
try:
    import cPickle as pickle
except ImportError:
    import pickle
import shutil


class PersistentDict(dict):
    ''' Persistent dictionary with an API compatible with shelve and anydbm.

    http://code.activestate.com/recipes/576642/ - Support for json, csv
    removed.

    The dict is kept in memory, so the dictionary operations run as fast as
    a regular dictionary.

    Write to disk is delayed until close or sync (similar to gdbm's fast mode).

    Input file format is automatically discovered.
    Output file format is selectable between pickle, json, and csv.
    All three serialization formats are backed by fast C implementations.

    '''

    def __init__(self, filename, flag='c', mode=None, *args, **kwds):
        self.flag = flag                    # r=readonly, c=create, or n=new
        self.mode = mode                    # None or an octal triple like 0644
        self.filename = filename
        if flag != 'n' and os.access(filename, os.R_OK):
            fileobj = open(filename, 'rb')
            with fileobj:
                self.load(fileobj)
        dict.__init__(self, *args, **kwds)

    def sync(self):
        'Write dict to disk'
        if self.flag == 'r':
            return
        filename = self.filename
        tempname = filename + '.tmp'
        fileobj = open(tempname, 'wb')
        try:
            self.dump(fileobj)
        except Exception:
            os.remove(tempname)
            raise
        finally:
            fileobj.close()
        shutil.move(tempname, self.filename)    # atomic commit
        if self.mode is not None:
            os.chmod(self.filename, self.mode)

    def close(self):
        self.sync()

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.close()

    def dump(self, fileobj):
        pickle.dump(dict(self), fileobj, 2)

    def load(self, fileobj):
        return self.update(pickle.load(fileobj))


def enter_time(times, spec):
    if not spec:
        spec = raw_input().split()
    if spec[0].startswith('@'):
        xtime = spec.pop(0)[1:]
        if len(xtime) == 4:
            time = datetime.datetime.combine(
                datetime.date.today(),
                datetime.datetime.strptime(xtime, '%H%M').timetz())
        elif len(xtime) == 12:
            time = datetime.datetime.strptime(xtime, '%Y%m%d%H%M')
        else:
            print "Can't handle time spec %r" % xtime
            return
    else:
        time = datetime.datetime.now()
    project = ' '.join(spec)
    for i in xrange(len(times), -1, -1):
        if i > 0 and times[i - 1][1] < time:
            break
    times.insert(i, (project, time))


def clear_times(times, spec):
    if spec:
        cutoff = datetime.datetime.strptime(spec[0], '%Y-%m-%d')
        while times[0][1] < cutoff:
            del times[0]
    else:
        del times[:]


def display_times(times, spec):
    if not times:
        return

    summary = collections.defaultdict(lambda: collections.defaultdict(float))
    prev = ('out', 0)
    times = times[:]
    if times[-1][0] != 'out':
        times.append(('out', datetime.datetime.now()))
    for entry in times:
        t = entry[1]
        proj = prev[0]
        day = t.strftime('%Y-%m-%d')
        if proj != 'out':
            summary[day][proj] += (t - prev[1]).total_seconds()
        prev = entry

    for day in sorted(summary):
        print '{0}:'.format(day)
        total = 0.0
        for proj in summary[day]:
            total += summary[day][proj]
            print '    {0}: {1:.1f}'.format(proj,
                                            summary[day][proj] / 3600)
        print '---------------------------'
        print '    Total: {0:.1f}'.format(total / 3600)


def list_projects(times, spec):
    for project, _ in itertools.groupby(sorted(times), operator.itemgetter(0)):
        print project


def current_project(times, spec):
    if not times:
        print 'out'
    else:
        print times[-1][0]


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    command_group = parser.add_mutually_exclusive_group()
    command_group.add_argument('--enter',
                               action='store_const',
                               dest='action',
                               const=enter_time,
                               help='Enter time')
    command_group.add_argument('--clear',
                               action='store_const',
                               dest='action',
                               const=clear_times,
                               help='Clear time')
    command_group.add_argument('--list',
                               action='store_const',
                               dest='action',
                               const=display_times,
                               help='Display all entered time.')
    command_group.add_argument('--projects',
                               action='store_const',
                               dest='action',
                               const=list_projects,
                               help='Display all known projects, one per line')
    command_group.add_argument('--current',
                               action='store_const',
                               dest='action',
                               const=current_project,
                               help='Display the current project')
    command_group.set_defaults(action=display_times)
    parser.add_argument('spec',
                        nargs='*')
    args = parser.parse_args()

    with PersistentDict(os.path.expanduser('~/.timecard'), mode=0600) as shelf:
        times = shelf.setdefault('times', [])
        args.action(times, args.spec)
